"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLogger = exports.createLogger = exports.VueLogger = void 0;
const vue_1 = require("vue");
const isProduction = process.env.NODE_ENV === 'production';
const loggerSymbol = Symbol('vue-logger-plugin');
const levels = ['debug', 'info', 'warn', 'error', 'log'];
const defaultOptions = {
    enabled: true,
    consoleEnabled: true,
    level: 'debug',
    callerInfo: false,
    prefixFormat: ({ level, caller }) => (caller
        ? `[${level.toUpperCase()}] [${caller === null || caller === void 0 ? void 0 : caller.fileName}:${caller === null || caller === void 0 ? void 0 : caller.functionName}:${caller === null || caller === void 0 ? void 0 : caller.lineNumber}]`
        : `[${level.toUpperCase()}]`)
};
class VueLogger {
    constructor(options) {
        this.apply(options);
        this._consoleFunctions = levels.filter(lvl => typeof console[lvl] === 'function');
    }
    apply(options) {
        const fallback = this._options || defaultOptions;
        this._options = { ...fallback, ...options };
        this.installHooks(this._options.beforeHooks);
        this.installHooks(this._options.afterHooks);
    }
    debug(...args) {
        this.invoke('debug', ...args)
            .then(() => { })
            .catch(() => { });
    }
    info(...args) {
        this.invoke('info', ...args)
            .then(() => { })
            .catch(() => { });
    }
    warn(...args) {
        this.invoke('warn', ...args)
            .then(() => { })
            .catch(() => { });
    }
    error(...args) {
        this.invoke('error', ...args)
            .then(() => { })
            .catch(() => { });
    }
    log(...args) {
        this.invoke('log', ...args)
            .then(() => { })
            .catch(() => { });
    }
    async invoke(level, ...args) {
        if (this._options.enabled && levels.indexOf(level) >= levels.indexOf(this._options.level)) {
            const caller = this._options.callerInfo ? this.getCallerInfo() : undefined;
            const event = { level, caller, argumentArray: args };
            await this.invokeHooks(this._options.beforeHooks, event);
            if (this._options.consoleEnabled) {
                const msgPrefix = this._options.prefixFormat({ level, caller });
                if (this._consoleFunctions.indexOf(level) >= 0) {
                    console[level](msgPrefix, ...args);
                }
                else {
                    console.log(msgPrefix, ...args);
                }
            }
            await this.invokeHooks(this._options.afterHooks, event);
        }
    }
    installHooks(hooks) {
        if (hooks && hooks.length > 0) {
            for (const hook of hooks) {
                if (hook.install) {
                    try {
                        hook.install(this._options);
                    }
                    catch (err) {
                        console.warn('LoggerHook install failure', err);
                    }
                }
            }
        }
    }
    async invokeHooks(hooks, event) {
        if (hooks && hooks.length > 0) {
            for (const hook of hooks) {
                try {
                    await hook.run(event);
                }
                catch (err) {
                    console.warn('LoggerHook run failure', err);
                }
            }
        }
    }
    getCallerInfo() {
        const e = new Error();
        if (e.stack) {
            try {
                const frames = e.stack.split('\n');
                const callerFrameIndex = frames[0].startsWith('Error') ? 4 : 3;
                const callerFrame = e.stack.split('\n')[callerFrameIndex].trim().replace('(', '').replace(')', '');
                let functionName;
                if (callerFrame.indexOf('at ') > -1) {
                    functionName = callerFrame.substring(callerFrame.indexOf('at ') + 3, callerFrame.lastIndexOf(' ')).split('.').reverse()[0];
                }
                else if (callerFrame.indexOf('@') > -1) {
                    functionName = callerFrame.substring(0, callerFrame.indexOf('@'));
                }
                const callerLocationParts = callerFrame.split(':').reverse();
                const fileName = callerLocationParts[2].substring(Math.max(callerLocationParts[2].lastIndexOf('/'), callerLocationParts[2].lastIndexOf('\\')) + 1).split('?')[0];
                const lineNumber = callerLocationParts[1];
                return { functionName, fileName, lineNumber };
            }
            catch (err) {
                if (!isProduction) {
                    console.debug('vue-logger-plugin :: failed to determine caller function info');
                }
            }
        }
        return undefined;
    }
    get enabled() {
        return this._options.enabled;
    }
    get level() {
        return this._options.level;
    }
    install(app) {
        app.provide(loggerSymbol, this);
        app.config.globalProperties.$log = this;
        app.config.globalProperties.$logger = this;
    }
}
exports.VueLogger = VueLogger;
function createLogger(options = {}) {
    return new VueLogger(options);
}
exports.createLogger = createLogger;
function useLogger() {
    const logger = vue_1.inject(loggerSymbol);
    if (!logger && !isProduction) {
        console.warn('vue-logger-plugin :: useLogger missing inject');
    }
    return logger;
}
exports.useLogger = useLogger;
//# sourceMappingURL=logger.js.map